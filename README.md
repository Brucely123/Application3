# Application3
Analysis Questions


Polling vs. Interrupt: In your own words, why is using an ISR + semaphore to signal the logger task more efficient or more responsive than having the task constantly poll the button status? What problems of polling does this design avoid?
**By eliminating the need for continual CPU cycles to check the button status, using an ISR (Interrupt Service Routine) is significantly more efficient and responsive than polling. LoggerTasks that poll the GPIO state consume power and CPU time even if no action is taken. Using a semaphore to wake the LoggerTask, the ISR is triggered only if the button is actually pressed, thus avoiding unnecessary CPU usage and latency. By eliminating busy-wait loops, we can ensure low-latency responsiveness.**

ISR Design: Why must we use special FreeRTOS APIs (functions with FromISR in their name) inside an ISR? What could go wrong if a regular blocking call (e.g. xSemaphoreTake) was called inside an ISR?
**Rather than using regular blocking calls like xSemaphoreTake() in interrupt context, we must use special FreeRTOS functions such as xSemaphoreGiveFromISR() instead. A blocking API may suspend a task or yield the CPU during an interrupt, which could cause the scheduler to behave incorrectly. As a result of using FromISR versions, the kernel can function safely after an ISR completes and defer context switching. As a result of the invalid context switching that happens when blocking calls like xSemaphoreTake() are used in an ISR, unexpected behavior may occur.**


Real-Time Behavior: Assume the LightSensorTask is running (e.g. it just started reading the ADC) at the moment the button is pressed. Describe what happens in the system when that interrupt fires. Include the roles of interrupt priority, the xHigherPriorityTaskWoken/portYIELD_FROM_ISR mechanism, and task priorities in determining what code runs next. Does the logger task preempt the sensor task immediately, or does it wait until the sensor task blocks? Why?
**ISRs are triggered immediately when the button is pressed if the LightSensorTask is running. After calling xSemaphoreGiveFromISR(), the ISR sets the xHigherPriorityTaskWoken flag to pdTRUE since LoggerTask (priority 3) has priority over LightSensorTask (priority 2). Once the ISR is complete, portYIELD_FROM_ISR() requests a context switch. The lower priority of the LoggerTask causes it to preempt the currently running LightSensorTask and start running the LoggerTask immediately. Logs are compressed and printed by the Logger. In order to resume the LightSensorTask, it must block again (after completing its cycle).**

Core Affinity: All tasks were pinned to Core 1. If we hadn’t pinned tasks (allowing them to run on either core), what nondeterministic behaviors might occur in this lab when the button is pressed? (Consider that the ISR is handled on a particular core and the unblocked task might run on a different core if not pinned – how could that complicate the sequence?) What benefits did pinning to one core provide for understanding this lab?
**RTOS allows tasks to be moved between cores if tasks are not pinned to Core 1. The result could be nondeterministic behavior, especially when the ISR is synchronized with the task. There may be some unexpected latency or race conditions caused by the ISR (which always runs on the core that received the interrupt, typically Core 0) signaling a semaphore, but the LoggerTask is scheduled on Core 1 with a slight delay. When all tasks are pinned to Core 1, predictable execution and timing can be ensured, which is important for understanding real-time behavior in the lab and avoiding subtle bugs caused by task migration.**

Light Sensor Logging: In your implementation, how did you handle the sensor data sharing between the LightSensorTask and the LoggerTask? Did you use any form of mutual exclusion or copying to prevent conflicts? If the logger task runs at a higher priority while the sensor task is in the middle of writing to the buffer, what issues could arise and how could they be mitigated in a more robust design (consider data integrity)?
**LightSensorTask and LoggerTask can access the shared adc_log buffer safely with a mutex (xLogMutex). A LoggerTask reads the buffer by locking a mutex, copying the data to a local array, then releasing it. By doing this, it ensures there are no conflicts or race conditions, even if LightSensorTask is currently writing. LoggerTask may, under more robust designs, preempt LightSensorTask before writing to the buffer, causing partial data to be logged. In order to prevent this, it might be better to suspend the sensor task (as we did), or to use a ring buffer that maintains integrity by using atomic writes or double-buffering.**

Task Priorities: If we accidentally assigned the LoggerTask a lower priority (say 1) and the Blink task a higher priority (say 3), describe what would happen when the button is pressed. Would the log still dump immediately? Why or why not? Relate this to the concept of preemptive scheduling and priority inversion (if any).

**LoggerTasks with lower priorities than Blink tasks (Logger = 1, Blink = 3) do not preempt the blink task when the button is pressed. There would be constant toggling of the LED, which delayed the log dump due to the LoggerTask not running immediately. The lower-priority task (Logger) cannot run because a higher-priority task (Blink) is always ready, which is a classic example of priority inversion. Real-time responsiveness is compromised by this. By using preemptive scheduling, the most critical task (Logger) runs first, as intended.**

Resource Usage: The button ISR defers a potentially long operation (compressing and printing log data) to a task. Chapter 7 of Mastering FreeRTOS suggests keeping ISRs short. What are the reasons for minimizing work in ISRs in a real-time system? List two reasons and connect them to this lab (hint: think about interrupt nesting, scheduler ticking, or other tasks’ latencies).
**While interrupts run, the scheduler is unable to handle ticks, resulting in delays in timekeeping and scheduling decisions. This lab would be delayed if the entire log compression was placed in the ISR, which would delay low-priority tasks such as sensor reading and blinking. In interrupts, nested interrupts are disabled (unless configured), so longer ISRs can prevent high-priority or time-critical interrupts from firing. By deferring work to LoggerTask, we maintain the system's responsiveness and real-time safety.**



Chapter Connections: Identify one concept from the readings (“Mastering the FreeRTOS Kernel” Ch. 7 or the “Practical RT Systems” Ch. 8) that you applied in your solution. Briefly quote or paraphrase the resource and explain how your implementation reflects that concept. For example, you might mention “Using a binary semaphore to synchronize an ISR and a task without polling, as suggested in the text..."
**Our implementation follows the pattern described in "Mastering the FreeRTOS Kernel" Chapter 7: "Use a binary semaphore to synchronize a task with an ISR when an external event occurs rather than polling." The button ISR signals the LoggerTask by using a binary semaphore (xButtonSem). Based on FreeRTOS's real-time design principles, the LoggerTask then performs all heavy processing outside the ISR. The separation of concerns between interrupt handling and task scheduling is also emphasized in both FreeRTOS and Practical RT Systems literature.**




